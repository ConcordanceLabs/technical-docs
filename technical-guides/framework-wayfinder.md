---
icon: location-arrow
hidden: true
---

# Framework - Wayfinder

A full-stack framework that optimizes client-side rendering, interaction with the blockchain.&#x20;



Performant applications that can handle elastic&#x20;

1. **Define the Scope and Purpose**
2. performance, security, usability,

Built for developer extensibility, and seamless integration to the Anoma ecosystem.&#x20;

2. **Select the Right Technologies**

**Programming Language**: Choose a language that fits the purpose of your framework (e.g., JavaScript for frontend frameworks, Python or Go for backend services).

**Tools and Libraries**: Identify the core libraries or tools that will support the functionality you aim to build. For example, if it's a web framework, you'll need HTTP request handling, database interaction, and routing capabilities.

**Existing Ecosystems**: Leverage existing standards and protocols (e.g., REST, GraphQL, gRPC) to ensure compatibility with other systems and services.

3. **Design Modular Architecture**

**Core Components**: Break down the framework into reusable, modular components. These should be easy to extend or replace without modifying other parts of the system.

**Separation of Concerns**: Implement clear separation of concerns (SoC) by dividing the framework into distinct layers (e.g., presentation layer, business logic layer, data layer). This makes it easier to maintain and scale.

**Plugin System**: Consider designing the framework with a plugin or extension system to allow third-party or future integrations.

4. **Establish Design Patterns**

**Best Practices**: Implement common design patterns (e.g., MVC, microkernel, event-driven, dependency injection) to improve maintainability and scalability.

**Configuration**: Design a robust configuration system that supports environment-specific settings without hardcoding values.

**Error Handling**: Incorporate standardized error handling and logging to improve debugging and system monitoring.

5. **Create Abstraction Layers**

**User Interface**: Provide high-level abstractions for developers to easily interact with the framework without worrying about low-level details.

**API Design**: Design APIs that are intuitive, consistent, and well-documented. Favor simplicity but ensure flexibility for more advanced use cases.

6. **Implement Security and Testing**

**Security Features**: Include built-in security mechanisms such as authentication, authorization, input validation, and protection against common vulnerabilities (e.g., SQL injection, XSS).

**Testing Framework**: Build or integrate a testing framework that supports unit, integration, and end-to-end testing. Encourage test-driven development (TDD) for users of your framework.

7. **Documentation and Developer Experience (DX)**

**Comprehensive Documentation**: Provide clear and thorough documentation for both developers and users. This includes API references, examples, and best practices.

**Code Samples and Tutorials**: Offer examples and tutorials to help developers get started quickly.

**Error Messages and Warnings**: Ensure error messages are clear, actionable, and guide developers toward the solution.

8. **Optimization and Performance**

**Efficiency**: Optimize the framework for performance, focusing on minimizing resource usage and latency.

**Benchmarking**: Regularly benchmark your framework against common use cases to ensure it performs well under different conditions.

9. **Feedback and Iteration**

**Community Involvement**: Encourage feedback from early users to identify pain points and areas for improvement.

**Continuous Integration/Continuous Deployment (CI/CD)**: Automate the build and deployment process with CI/CD pipelines to ensure smooth and quick updates.

10. **Open-Source Considerations**

**Licensing**: Choose an appropriate license if the framework is open-source.

**Community Building**: Create a process for external contributions and establish clear guidelines for collaboration.

Enables&#x20;

* Private Data verification - no one needs to provide their personal data to verify their membership
* Application Sessions&#x20;
* Authentication and secrets&#x20;
* Authorization&#x20;
* protected routes
* server actions&#x20;

Deterministic&#x20;

idempotent.&#x20;

When an application is served Route code compiles down to self-contained packages&#x20;

Non-deterministic - when input is required. &#x20;



User sessions replace log in.&#x20;

ZKP supported auth to&#x20;
